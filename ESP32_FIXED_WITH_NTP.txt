// ============================================================
// FIXED ESP32 CODE - WITH NTP TIME SYNCHRONIZATION
// ============================================================
// 
// KEY CHANGES:
// 1. Added NTP time sync (configTime)
// 2. Real Unix timestamps instead of millis()
// 3. Better time handling across reboots
//
// ============================================================

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SH110X.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <WiFiManager.h>
#include <Preferences.h>
#include <ArduinoJson.h>
#include <time.h>  // ‚úÖ ADDED: For NTP time

// ==================== CONFIG ====================
#define DEVICE_ID "WM001"  // Change this for each device
#define FIREBASE_HOST "aquatrackx-default-rtdb.asia-southeast1.firebasedatabase.app"
#define FIREBASE_AUTH ""  // Leave blank if using public rules, or add your secret
#define FLOW_PIN 27
#define RELAY_PIN 19
#define BATTERY_PIN 35
#define CONFIG_BUTTON_PIN 0  // Boot button for reconfiguration

// ==================== GLOBALS ====================
Adafruit_SH1106G display(128, 64, &Wire, -1);
WiFiManager wm;
Preferences prefs;
HTTPClient http;

volatile int pulseCount = 0;
float flowRate = 0, totalLitres = 0;
bool valveState = false, wifiOK = false, registered = false;
int battery = 0;
unsigned long lastHistorySave = 0;

// ‚úÖ ADDED: Time variables
time_t now;
struct tm timeinfo;
bool timeSync = false;

// ==================== HELPERS ====================
void IRAM_ATTR pulseCounter() { 
  pulseCount++; 
}

void updateDisplay() {
  display.clearDisplay();
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.printf("Bat:%d%% Flow:%.1fL/m\nTotal:%.2fL\nValve:%s\n\nStatus:%s", 
    battery, flowRate, totalLitres, valveState ? "OPEN" : "CLOSED",
    registered ? "Online" : wifiOK ? "WiFi OK" : "Setup");
  display.display();
}

void setValve(bool state) {
  valveState = state;
  digitalWrite(RELAY_PIN, state ? HIGH : LOW);
  Serial.printf("Valve %s\n", state ? "OPENED" : "CLOSED");
}

void measureFlow() {
  static unsigned long lastTime = 0;
  if (millis() - lastTime > 1000) {
    detachInterrupt(FLOW_PIN);
    flowRate = pulseCount / 7.5;
    if (valveState && flowRate > 0.1) {
      totalLitres += flowRate / 60.0;
    }
    
    // Save total litres to flash every 10L
    static float lastSaved = 0;
    if (totalLitres - lastSaved >= 10) {
      prefs.begin("wm", false);
      prefs.putFloat("total", totalLitres);
      prefs.end();
      lastSaved = totalLitres;
      Serial.printf("Total saved: %.2fL\n", totalLitres);
    }
    
    pulseCount = 0;
    lastTime = millis();
    attachInterrupt(FLOW_PIN, pulseCounter, FALLING);
  }
}

// ==================== FIXED BATTERY READING WITH SMART CALIBRATION ====================
int readBatteryPercentage() {
  // Average 10 readings to reduce noise
  long adcSum = 0;
  for (int i = 0; i < 10; i++) {
    adcSum += analogRead(BATTERY_PIN);
    delay(1);
  }
  int adc = adcSum / 10;
  
  // Calculate voltage at GPIO35 (0-3.3V range)
  float gpioVoltage = (adc / 4095.0) * 3.3;
  
  // Calculate 5V rail voltage using voltage divider formula
  float rail5V = gpioVoltage * 3.1277;
  
  int batteryPercent;
  
  if (rail5V >= 4.95) {
    batteryPercent = 100;
  } else if (rail5V >= 4.80) {
    batteryPercent = map((int)(rail5V * 100), 480, 495, 80, 99);
  } else if (rail5V >= 4.50) {
    batteryPercent = map((int)(rail5V * 100), 450, 480, 30, 79);
  } else if (rail5V >= 4.20) {
    batteryPercent = map((int)(rail5V * 100), 420, 450, 10, 29);
  } else {
    batteryPercent = map((int)(rail5V * 100), 380, 420, 0, 9);
  }
  
  batteryPercent = constrain(batteryPercent, 0, 100);
  
  // Debug output every 10 seconds
  static unsigned long lastDebug = 0;
  if (millis() - lastDebug > 10000) {
    Serial.println("\n========== BATTERY STATUS ==========");
    Serial.printf("ADC: %d\n", adc);
    Serial.printf("GPIO35: %.3fV\n", gpioVoltage);
    Serial.printf("5V Rail: %.3fV\n", rail5V);
    Serial.printf("Battery: %d%%\n", batteryPercent);
    
    if (rail5V >= 4.95) {
      Serial.println("Status: EXCELLENT (USB/Full)");
    } else if (rail5V >= 4.80) {
      Serial.println("Status: GOOD");
    } else if (rail5V >= 4.50) {
      Serial.println("Status: FAIR");
    } else if (rail5V >= 4.20) {
      Serial.println("Status: LOW - Charge Soon");
    } else {
      Serial.println("Status: CRITICAL - Charge Now!");
    }
    Serial.println("====================================\n");
    lastDebug = millis();
  }
  
  return batteryPercent;
}

// ‚úÖ NEW: Setup NTP time synchronization
void setupTime() {
  Serial.println("‚è∞ Setting up NTP time synchronization...");
  
  // Configure NTP - using multiple time servers for reliability
  configTime(0, 0, "pool.ntp.org", "time.nist.gov", "time.google.com");
  
  // Set timezone (adjust for your location)
  // Example: "UTC-5" for EST, "UTC+5:30" for IST
  setenv("TZ", "UTC", 1);
  tzset();
  
  // Wait for time to sync (max 10 seconds)
  int retries = 0;
  Serial.print("Syncing");
  while (!time(&now) && retries < 20) {
    delay(500);
    Serial.print(".");
    retries++;
  }
  Serial.println();
  
  if (retries < 20 && now > 1000000000) {
    timeSync = true;
    Serial.println("‚úÖ Time synchronized successfully!");
    Serial.printf("Current Unix time: %ld\n", now);
    Serial.printf("Current time: %s", ctime(&now));
  } else {
    timeSync = false;
    Serial.println("‚ö† Time sync failed - will use millis() fallback");
    Serial.println("   Analytics may not work across reboots");
  }
}

// ‚úÖ NEW: Get current timestamp (real Unix timestamp or millis fallback)
unsigned long long getCurrentTimestamp() {
  if (timeSync && time(&now)) {
    // Return Unix timestamp in milliseconds
    return (unsigned long long)now * 1000ULL;
  } else {
    // Fallback to millis() if time not synced
    return (unsigned long long)millis();
  }
}

// ==================== FIREBASE HTTP ====================
String firebaseURL(String path) {
  String url = "https://" + String(FIREBASE_HOST) + path + ".json";
  if (String(FIREBASE_AUTH).length() > 0) {
    url += "?auth=" + String(FIREBASE_AUTH);
  }
  return url;
}

bool firebasePUT(String path, String json) {
  if (!wifiOK) return false;
  
  for (int retry = 0; retry < 3; retry++) {
    http.begin(firebaseURL(path));
    http.addHeader("Content-Type", "application/json");
    int code = http.PUT(json);
    String response = http.getString();
    http.end();
    
    if (code == 200) {
      Serial.printf("PUT %s: OK\n", path.c_str());
      return true;
    }
    
    Serial.printf("PUT %s: FAILED (%d) - Retry %d/3\n", path.c_str(), code, retry + 1);
    delay(1000);
  }
  
  Serial.printf("PUT %s: FAILED after 3 retries\n", path.c_str());
  return false;
}

bool firebasePATCH(String path, String json) {
  if (!wifiOK) return false;
  
  http.begin(firebaseURL(path));
  http.addHeader("Content-Type", "application/json");
  int code = http.PATCH(json);
  String response = http.getString();
  http.end();
  
  if (code == 200) {
    Serial.printf("PATCH %s: OK\n", path.c_str());
    return true;
  } else {
    Serial.printf("PATCH %s: FAILED (%d) - %s\n", path.c_str(), code, response.c_str());
    return false;
  }
}

String firebaseGET(String path) {
  if (!wifiOK) return "";
  
  http.begin(firebaseURL(path));
  int code = http.GET();
  String response = (code == 200) ? http.getString() : "";
  http.end();
  
  return response;
}

bool firebaseDELETE(String path) {
  if (!wifiOK) return false;
  
  http.begin(firebaseURL(path));
  int code = http.sendRequest("DELETE");
  http.end();
  
  if (code == 200) {
    Serial.printf("DELETE %s: OK\n", path.c_str());
    return true;
  } else {
    Serial.printf("DELETE %s: FAILED (%d)\n", path.c_str(), code);
    return false;
  }
}

// ==================== DEVICE REGISTRATION ====================
void registerDevice() {
  if (registered) return;
  
  Serial.println("Registering device with Firebase...");
  
  DynamicJsonDocument doc(512);
  doc["deviceId"] = DEVICE_ID;
  doc["deviceName"] = "AquaTrackX " + String(DEVICE_ID);
  doc["name"] = "AquaTrackX " + String(DEVICE_ID);
  doc["location"] = "Not Set";
  doc["type"] = "smart-water-monitor";
  doc["status"] = "online";
  
  // ‚úÖ FIXED: Use real timestamp
  unsigned long long timestamp = getCurrentTimestamp();
  doc["addedAt"] = timestamp / 1000;  // Unix timestamp in seconds
  doc["lastSeen"] = timestamp;        // Unix timestamp in milliseconds
  
  doc["version"] = "1.0.0";
  doc["firmwareDate"] = __DATE__;
  
  String json;
  serializeJson(doc, json);
  
  bool success = firebasePUT("/devices/" + String(DEVICE_ID) + "/info", json);
  
  if (success) {
    registered = true;
    Serial.println("‚úÖ Device registered successfully");
  } else {
    Serial.println("‚ùå Device registration failed");
  }
}

// ==================== UPDATE FIREBASE DATA ====================
void updateFirebase() {
  static unsigned long lastUpdate = 0;
  if (!wifiOK || millis() - lastUpdate < 3000) return;
  
  // ‚úÖ FIXED: Get real timestamp
  unsigned long long timestamp = getCurrentTimestamp();
  
  DynamicJsonDocument dataDoc(512);
  dataDoc["deviceId"] = DEVICE_ID;
  dataDoc["flowRate"] = flowRate;
  dataDoc["totalLitres"] = totalLitres;
  dataDoc["valveState"] = valveState ? "OPEN" : "CLOSED";
  dataDoc["status"] = "online";
  dataDoc["batteryPercentage"] = battery;
  dataDoc["timestamp"] = timestamp;  // ‚úÖ Real Unix timestamp in ms
  
  String dataJson;
  serializeJson(dataDoc, dataJson);
  
  bool dataSuccess = firebasePUT("/devices/" + String(DEVICE_ID) + "/data", dataJson);
  
  // Update device info status and lastSeen
  DynamicJsonDocument infoDoc(256);
  infoDoc["status"] = "online";
  infoDoc["lastSeen"] = timestamp;
  
  String infoJson;
  serializeJson(infoDoc, infoJson);
  
  bool infoSuccess = firebasePATCH("/devices/" + String(DEVICE_ID) + "/info", infoJson);
  
  if (dataSuccess && infoSuccess) {
    Serial.println("‚úÖ Firebase data updated");
    if (timeSync) {
      Serial.printf("   Timestamp: %llu (%s)\n", timestamp, ctime(&now));
    }
  } else {
    Serial.println("‚ö† Firebase update incomplete");
  }
  
  lastUpdate = millis();
}

// ==================== SAVE HISTORY ====================
void saveHistory() {
  static unsigned long lastHistory = 0;
  
  // Save history every 5 minutes (288 records per day)
  if (!wifiOK || millis() - lastHistory < 300000) return;
  
  // Only save history if there's flow or valve state changed
  static bool lastValveState = false;
  static float lastFlowRate = 0;
  
  bool shouldSave = (flowRate > 0.1) || 
                    (valveState != lastValveState) || 
                    (abs(flowRate - lastFlowRate) > 0.5);
  
  if (!shouldSave) {
    lastHistory = millis();
    return;
  }
  
  Serial.println("üíæ Saving history record...");
  
  // ‚úÖ FIXED: Get real timestamp
  unsigned long long timestamp = getCurrentTimestamp();
  
  DynamicJsonDocument historyDoc(512);
  historyDoc["timestamp"] = timestamp;  // ‚úÖ Real Unix timestamp in ms
  historyDoc["flowRate"] = flowRate;
  historyDoc["totalLitres"] = totalLitres;
  historyDoc["valveState"] = valveState ? "OPEN" : "CLOSED";
  historyDoc["batteryPercentage"] = battery;
  historyDoc["recordedAt"] = millis();  // Keep millis for debugging
  
  String historyJson;
  serializeJson(historyDoc, historyJson);
  
  // ‚úÖ FIXED: Use real timestamp as key (in seconds for readability)
  String historyKey = String((unsigned long)(timestamp / 1000));
  
  bool success = firebasePUT("/history/" + String(DEVICE_ID) + "/" + historyKey, historyJson);
  
  if (success) {
    Serial.println("‚úÖ History record saved");
    Serial.printf("   Timestamp: %llu\n", timestamp);
    if (timeSync) {
      Serial.printf("   Time: %s", ctime(&now));
    }
    lastValveState = valveState;
    lastFlowRate = flowRate;
  } else {
    Serial.println("‚ùå History save failed");
  }
  
  lastHistory = millis();
}

// ==================== CHECK COMMANDS ====================
void checkCommands() {
  if (!wifiOK) return;
  
  static unsigned long lastCheck = 0;
  if (millis() - lastCheck < 2000) return;
  
  String valveCmd = firebaseGET("/devices/" + String(DEVICE_ID) + "/commands/valveControl");
  valveCmd.trim();
  valveCmd.replace("\"", "");
  
  if (valveCmd == "true") {
    Serial.println("üì© Valve OPEN command received");
    setValve(true);
    firebaseDELETE("/devices/" + String(DEVICE_ID) + "/commands/valveControl");
  } else if (valveCmd == "false") {
    Serial.println("üì© Valve CLOSE command received");
    setValve(false);
    firebaseDELETE("/devices/" + String(DEVICE_ID) + "/commands/valveControl");
  }
  
  String resetCmd = firebaseGET("/devices/" + String(DEVICE_ID) + "/commands/resetTotal");
  resetCmd.trim();
  resetCmd.replace("\"", "");
  
  if (resetCmd == "true") {
    Serial.println("üì© Reset Total command received");
    totalLitres = 0;
    prefs.begin("wm", false);
    prefs.putFloat("total", 0);
    prefs.end();
    firebaseDELETE("/devices/" + String(DEVICE_ID) + "/commands/resetTotal");
    Serial.println("‚úÖ Total litres reset to 0");
  }
  
  lastCheck = millis();
}

// ==================== WIFI SETUP ====================
bool setupWiFiManager() {
  display.clearDisplay();
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.println("WiFi Setup Mode");
  display.println("Connect to:");
  display.setTextSize(2);
  display.setCursor(0, 20);
  display.println("AquaTrackX");
  display.println(DEVICE_ID);
  display.setTextSize(1);
  display.setCursor(0, 50);
  display.println("No password needed");
  display.display();

  wm.setTitle("AquaTrackX Setup");
  wm.setConfigPortalTimeout(180);
  
  String apName = "AquaTrackX_" + String(DEVICE_ID);
  bool res = wm.autoConnect(apName.c_str());
  
  if (!res) {
    Serial.println("Failed to connect and hit timeout");
    return false;
  } else {
    Serial.println("‚úÖ Connected to WiFi!");
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());
    Serial.print("SSID: ");
    Serial.println(WiFi.SSID());
    Serial.print("RSSI: ");
    Serial.println(WiFi.RSSI());
    
    wifiOK = true;
    
    // ‚úÖ ADDED: Setup time sync after WiFi connects
    setupTime();
    
    registerDevice();
    return true;
  }
}

// ==================== SETUP ====================
void setup() {
  Serial.begin(115200);
  Serial.println("\n\n========================================");
  Serial.println("Starting AquaTrackX Water Monitor");
  Serial.println("Device ID: " + String(DEVICE_ID));
  Serial.println("Firmware Date: " + String(__DATE__));
  Serial.println("========================================\n");
  
  pinMode(FLOW_PIN, INPUT_PULLUP);
  pinMode(RELAY_PIN, OUTPUT);
  pinMode(BATTERY_PIN, INPUT);
  pinMode(CONFIG_BUTTON_PIN, INPUT_PULLUP);
  digitalWrite(RELAY_PIN, LOW);
  attachInterrupt(FLOW_PIN, pulseCounter, FALLING);
  
  Wire.begin(21, 22);
  if (!display.begin(0x3C, true)) {
    Serial.println("SH1106 allocation failed");
  }
  
  display.clearDisplay();
  display.setTextColor(SH110X_WHITE);
  display.setTextSize(2);
  display.setCursor(5, 20);
  display.println("AquaTrackX");
  display.setTextSize(1);
  display.setCursor(20, 45);
  display.print(DEVICE_ID);
  display.display();
  delay(2000);
  
  prefs.begin("wm", false);
  totalLitres = prefs.getFloat("total", 0);
  prefs.end();
  Serial.printf("Loaded total litres: %.2fL\n", totalLitres);
  
  if (digitalRead(CONFIG_BUTTON_PIN) == LOW) {
    display.clearDisplay();
    display.setCursor(0, 20);
    display.println("Resetting WiFi...");
    display.display();
    delay(2000);
    wm.resetSettings();
    Serial.println("WiFi settings reset");
  }
  
  if (!setupWiFiManager()) {
    Serial.println("‚ùå WiFi setup failed, restarting in 3 seconds...");
    delay(3000);
    ESP.restart();
  }
  
  Serial.println("\n‚úÖ Setup complete - entering main loop\n");
  
  // ‚úÖ ADDED: Print time sync status
  if (timeSync) {
    Serial.println("‚è∞ Time sync: ACTIVE");
    Serial.println("   Analytics will work across reboots");
  } else {
    Serial.println("‚ö† Time sync: FAILED");
    Serial.println("   Analytics limited to current session");
  }
}

// ==================== MAIN LOOP ====================
void loop() {
  static unsigned long lastBattery = 0, lastDisplay = 0;
  static unsigned long buttonPressStart = 0;
  
  if (digitalRead(CONFIG_BUTTON_PIN) == LOW) {
    if (buttonPressStart == 0) {
      buttonPressStart = millis();
    } else if (millis() - buttonPressStart > 5000) {
      display.clearDisplay();
      display.setCursor(0, 20);
      display.println("Resetting WiFi...");
      display.display();
      wm.resetSettings();
      delay(1000);
      ESP.restart();
    }
  } else {
    buttonPressStart = 0;
  }
  
  if (millis() - lastBattery > 10000) {
    battery = readBatteryPercentage();
    lastBattery = millis();
  }
  
  measureFlow();
  
  if (wifiOK && WiFi.status() == WL_CONNECTED) {
    // ‚úÖ ADDED: Re-sync time periodically (every hour)
    static unsigned long lastTimeSync = 0;
    if (millis() - lastTimeSync > 3600000) {  // 1 hour
      setupTime();
      lastTimeSync = millis();
    }
    
    updateFirebase();
    saveHistory();
    checkCommands();
  } else if (wifiOK && WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ö† WiFi connection lost, attempting to reconnect...");
    wifiOK = false;
    registered = false;
    timeSync = false;  // ‚úÖ Reset time sync flag
    
    if (WiFi.reconnect()) {
      Serial.println("‚úÖ WiFi reconnected");
      wifiOK = true;
      setupTime();  // ‚úÖ Re-sync time
      registerDevice();
    } else {
      Serial.println("‚ùå Reconnect failed, restarting WiFiManager...");
      setupWiFiManager();
    }
  }
  
  if (millis() - lastDisplay > 500) {
    updateDisplay();
    lastDisplay = millis();
  }
  
  delay(10);
}
