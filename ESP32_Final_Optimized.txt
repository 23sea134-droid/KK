// ============================================================
// OPTIMIZED ESP32 CODE - AquaTrackX Water Monitor v2.0
// ============================================================
// 
// ‚úÖ IMPROVEMENTS:
// 1. Beautiful OLED display with proper spacing
// 2. Clear WiFi setup guidance (step-by-step)
// 3. Professional welcome screen
// 4. Better layout for flow rate, total, battery, valve
// 5. NTP time sync for accurate analytics
// 6. Smooth state transitions
// 7. Better error handling
//
// ============================================================

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SH110X.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <WiFiManager.h>
#include <Preferences.h>
#include <ArduinoJson.h>
#include <time.h>

// ==================== CONFIG ====================
#define DEVICE_ID "WM001"  // Change this for each device
#define FIRMWARE_VERSION "2.0.0"
#define FIREBASE_HOST "aquatrackx-default-rtdb.asia-southeast1.firebasedatabase.app"
#define FIREBASE_AUTH ""  // Leave blank if using public rules

// Hardware pins
#define FLOW_PIN 27
#define RELAY_PIN 19
#define BATTERY_PIN 35
#define CONFIG_BUTTON_PIN 0  // Boot button

// Timing intervals
#define FLOW_MEASURE_INTERVAL 1000
#define FIREBASE_UPDATE_INTERVAL 3000
#define HISTORY_SAVE_INTERVAL 300000
#define BATTERY_UPDATE_INTERVAL 10000
#define DISPLAY_UPDATE_INTERVAL 500
#define COMMAND_CHECK_INTERVAL 2000

// ==================== GLOBALS ====================
Adafruit_SH1106G display(128, 64, &Wire, -1);
WiFiManager wm;
Preferences prefs;
HTTPClient http;

// Flow measurement
volatile int pulseCount = 0;
float flowRate = 0.0;
float totalLitres = 0.0;

// System state
bool valveState = false;
bool wifiOK = false;
bool registered = false;
int batteryPercent = 0;

// Time sync
time_t now;
bool timeSync = false;

// Display states
enum DisplayState {
  STATE_WELCOME,
  STATE_WIFI_GUIDE,
  STATE_CONNECTING,
  STATE_CONNECTED,
  STATE_NORMAL,
  STATE_ERROR
};
DisplayState currentState = STATE_WELCOME;
unsigned long stateStartTime = 0;

// ==================== INTERRUPT ====================
void IRAM_ATTR pulseCounter() { 
  pulseCount++; 
}

// ==================== DISPLAY FUNCTIONS ====================

void displayWelcome() {
  display.clearDisplay();
  display.setTextColor(SH110X_WHITE);
  
  // Title with larger font
  display.setTextSize(2);
  display.setCursor(8, 8);
  display.println("AquaTrackX");
  
  // Underline
  display.drawLine(8, 28, 120, 28, SH110X_WHITE);
  
  // Device ID
  display.setTextSize(1);
  display.setCursor(24, 36);
  display.print("Device: ");
  display.println(DEVICE_ID);
  
  // Version
  display.setCursor(30, 50);
  display.print("Version ");
  display.println(FIRMWARE_VERSION);
  
  display.display();
}

void displayWiFiGuide() {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SH110X_WHITE);
  
  // Header
  display.setCursor(10, 0);
  display.setTextSize(1);
  display.println("WiFi Setup Guide");
  display.drawLine(0, 11, 128, 11, SH110X_WHITE);
  
  // Step 1
  display.setCursor(0, 16);
  display.print("1. Connect phone to:");
  
  // SSID (larger)
  display.setTextSize(1);
  display.setCursor(8, 28);
  display.print("AquaTrackX_");
  display.println(DEVICE_ID);
  
  // Step 2
  display.setCursor(0, 40);
  display.print("2. Open browser");
  
  // Step 3
  display.setCursor(0, 50);
  display.print("3. Select your WiFi");
  
  display.display();
}

void displayConnecting() {
  static int dots = 0;
  static unsigned long lastUpdate = 0;
  
  if (millis() - lastUpdate > 500) {
    display.clearDisplay();
    display.setTextSize(1);
    
    // Title
    display.setCursor(18, 15);
    display.println("Connecting WiFi");
    
    // Animated dots
    display.setCursor(45, 35);
    for (int i = 0; i < dots; i++) {
      display.print(".");
    }
    
    display.display();
    
    dots = (dots + 1) % 4;
    lastUpdate = millis();
  }
}

void displayConnected() {
  display.clearDisplay();
  display.setTextSize(1);
  
  // Success icon (checkmark)
  display.fillCircle(64, 20, 12, SH110X_WHITE);
  display.setTextColor(SH110X_BLACK, SH110X_WHITE);
  display.setCursor(60, 15);
  display.setTextSize(2);
  display.print("*"); // Checkmark symbol
  
  display.setTextColor(SH110X_WHITE);
  display.setTextSize(1);
  
  // Message
  display.setCursor(25, 40);
  display.println("WiFi Connected!");
  
  display.setCursor(20, 52);
  display.println("Starting system...");
  
  display.display();
}

void displayNormal() {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SH110X_WHITE);
  
  // ======== LINE 1: Battery (with visual indicator) ========
  display.setCursor(0, 0);
  display.print("Battery: ");
  display.print(batteryPercent);
  display.print("%");
  
  // Battery bar (right side)
  int barWidth = map(batteryPercent, 0, 100, 0, 28);
  display.drawRect(96, 0, 30, 8, SH110X_WHITE);  // Battery outline
  display.fillRect(97, 1, barWidth, 6, SH110X_WHITE);  // Fill
  display.fillRect(126, 2, 2, 4, SH110X_WHITE);  // Battery tip
  
  // Divider
  display.drawLine(0, 10, 128, 10, SH110X_WHITE);
  
  // ======== LINE 2-3: Flow Rate (LARGE) ========
  display.setCursor(0, 14);
  display.setTextSize(1);
  display.print("Flow:");
  
  display.setTextSize(2);
  display.setCursor(45, 14);
  display.print(flowRate, 1);
  
  display.setTextSize(1);
  display.setCursor(105, 22);
  display.print("L/m");
  
  // Divider
  display.drawLine(0, 32, 128, 32, SH110X_WHITE);
  
  // ======== LINE 4-5: Total Usage (LARGE) ========
  display.setCursor(0, 36);
  display.setTextSize(1);
  display.print("Total:");
  
  display.setTextSize(2);
  display.setCursor(45, 36);
  if (totalLitres < 1000) {
    display.print(totalLitres, 1);
    display.setTextSize(1);
    display.setCursor(115, 44);
    display.print("L");
  } else {
    display.print(totalLitres / 1000.0, 2);
    display.setTextSize(1);
    display.setCursor(110, 44);
    display.print("kL");
  }
  
  // Divider
  display.drawLine(0, 54, 128, 54, SH110X_WHITE);
  
  // ======== LINE 6: Status Bar ========
  display.setTextSize(1);
  
  // Valve status (left)
  display.setCursor(0, 56);
  display.print("Valve:");
  display.print(valveState ? "OPEN" : "CLOSE");
  
  // Separator
  display.setCursor(68, 56);
  display.print("|");
  
  // Connection status (right)
  display.setCursor(75, 56);
  if (registered && wifiOK) {
    display.print("Online");
  } else if (wifiOK) {
    display.print("WiFi");
  } else {
    display.print("Offline");
  }
  
  display.display();
}

void displayError(const char* error) {
  display.clearDisplay();
  display.setTextSize(1);
  
  // Error icon (X)
  display.drawCircle(64, 20, 12, SH110X_WHITE);
  display.drawLine(58, 14, 70, 26, SH110X_WHITE);
  display.drawLine(70, 14, 58, 26, SH110X_WHITE);
  
  // Error title
  display.setCursor(48, 40);
  display.println("ERROR");
  
  // Error message
  display.setCursor(5, 52);
  display.println(error);
  
  display.display();
}

void updateDisplay() {
  switch (currentState) {
    case STATE_WELCOME:
      displayWelcome();
      break;
      
    case STATE_WIFI_GUIDE:
      displayWiFiGuide();
      break;
      
    case STATE_CONNECTING:
      displayConnecting();
      break;
      
    case STATE_CONNECTED:
      displayConnected();
      break;
      
    case STATE_NORMAL:
      displayNormal();
      break;
      
    case STATE_ERROR:
      // Error already displayed
      break;
  }
}

// ==================== VALVE CONTROL ====================
void setValve(bool state) {
  valveState = state;
  digitalWrite(RELAY_PIN, state ? HIGH : LOW);
  Serial.printf("üö∞ Valve %s\n", state ? "OPENED" : "CLOSED");
}

// ==================== FLOW MEASUREMENT ====================
void measureFlow() {
  static unsigned long lastMeasure = 0;
  
  if (millis() - lastMeasure >= FLOW_MEASURE_INTERVAL) {
    detachInterrupt(FLOW_PIN);
    
    flowRate = pulseCount / 7.5;
    
    if (valveState && flowRate > 0.1) {
      totalLitres += flowRate / 60.0;
    }
    
    // Save every 10L
    static float lastSaved = 0;
    if (totalLitres - lastSaved >= 10.0) {
      prefs.begin("aquatrack", false);
      prefs.putFloat("total", totalLitres);
      prefs.end();
      lastSaved = totalLitres;
      Serial.printf("üíæ Saved: %.2fL\n", totalLitres);
    }
    
    pulseCount = 0;
    lastMeasure = millis();
    attachInterrupt(FLOW_PIN, pulseCounter, FALLING);
  }
}

// ==================== BATTERY READING ====================
int readBatteryPercentage() {
  long adcSum = 0;
  for (int i = 0; i < 10; i++) {
    adcSum += analogRead(BATTERY_PIN);
    delay(1);
  }
  int adc = adcSum / 10;
  
  float gpioVoltage = (adc / 4095.0) * 3.3;
  float rail5V = gpioVoltage * 3.1277;
  
  int batteryPercent;
  
  if (rail5V >= 4.95) {
    batteryPercent = 100;
  } else if (rail5V >= 4.80) {
    batteryPercent = map((int)(rail5V * 100), 480, 495, 80, 99);
  } else if (rail5V >= 4.50) {
    batteryPercent = map((int)(rail5V * 100), 450, 480, 30, 79);
  } else if (rail5V >= 4.20) {
    batteryPercent = map((int)(rail5V * 100), 420, 450, 10, 29);
  } else {
    batteryPercent = map((int)(rail5V * 100), 380, 420, 0, 9);
  }
  
  batteryPercent = constrain(batteryPercent, 0, 100);
  
  static unsigned long lastDebug = 0;
  if (millis() - lastDebug > 30000) {
    Serial.println("\n====== BATTERY ======");
    Serial.printf("ADC: %d\n", adc);
    Serial.printf("GPIO: %.3fV\n", gpioVoltage);
    Serial.printf("5V: %.3fV\n", rail5V);
    Serial.printf("Battery: %d%%\n", batteryPercent);
    Serial.println("=====================\n");
    lastDebug = millis();
  }
  
  return batteryPercent;
}

// ==================== TIME SYNC ====================
void setupTime() {
  Serial.println("‚è∞ Syncing time...");
  
  configTime(0, 0, "pool.ntp.org", "time.nist.gov", "time.google.com");
  setenv("TZ", "UTC", 1);
  tzset();
  
  int retries = 0;
  Serial.print("Syncing");
  while (!time(&now) && retries < 20) {
    delay(500);
    Serial.print(".");
    retries++;
  }
  Serial.println();
  
  if (retries < 20 && now > 1000000000) {
    timeSync = true;
    Serial.println("‚úÖ Time synced!");
    Serial.printf("Unix: %ld\n", now);
  } else {
    timeSync = false;
    Serial.println("‚ö†Ô∏è Time sync failed");
  }
}

unsigned long long getCurrentTimestamp() {
  if (timeSync && time(&now)) {
    return (unsigned long long)now * 1000ULL;
  }
  return (unsigned long long)millis();
}

// ==================== FIREBASE ====================
String firebaseURL(String path) {
  String url = "https://" + String(FIREBASE_HOST) + path + ".json";
  if (String(FIREBASE_AUTH).length() > 0) {
    url += "?auth=" + String(FIREBASE_AUTH);
  }
  return url;
}

bool firebasePUT(String path, String json) {
  if (!wifiOK) return false;
  
  for (int retry = 0; retry < 3; retry++) {
    http.begin(firebaseURL(path));
    http.addHeader("Content-Type", "application/json");
    http.setTimeout(5000);
    
    int code = http.PUT(json);
    http.end();
    
    if (code == 200) return true;
    
    Serial.printf("‚ö†Ô∏è PUT retry %d/3\n", retry + 1);
    delay(1000);
  }
  
  return false;
}

bool firebasePATCH(String path, String json) {
  if (!wifiOK) return false;
  
  http.begin(firebaseURL(path));
  http.addHeader("Content-Type", "application/json");
  http.setTimeout(5000);
  
  int code = http.PATCH(json);
  http.end();
  
  return (code == 200);
}

String firebaseGET(String path) {
  if (!wifiOK) return "";
  
  http.begin(firebaseURL(path));
  http.setTimeout(5000);
  
  int code = http.GET();
  String response = (code == 200) ? http.getString() : "";
  http.end();
  
  return response;
}

bool firebaseDELETE(String path) {
  if (!wifiOK) return false;
  
  http.begin(firebaseURL(path));
  http.setTimeout(5000);
  
  int code = http.sendRequest("DELETE");
  http.end();
  
  return (code == 200);
}

// ==================== DEVICE REGISTRATION ====================
void registerDevice() {
  if (registered) return;
  
  Serial.println("üìù Registering...");
  
  unsigned long long timestamp = getCurrentTimestamp();
  
  DynamicJsonDocument doc(512);
  doc["deviceId"] = DEVICE_ID;
  doc["name"] = "AquaTrackX " + String(DEVICE_ID);
  doc["deviceName"] = "AquaTrackX " + String(DEVICE_ID);
  doc["location"] = "Not Set";
  doc["type"] = "smart-water-monitor";
  doc["status"] = "online";
  doc["addedAt"] = timestamp / 1000;
  doc["lastSeen"] = timestamp;
  doc["version"] = FIRMWARE_VERSION;
  doc["firmwareDate"] = __DATE__;
  
  String json;
  serializeJson(doc, json);
  
  if (firebasePUT("/devices/" + String(DEVICE_ID) + "/info", json)) {
    registered = true;
    Serial.println("‚úÖ Registered");
  }
}

// ==================== UPDATE FIREBASE ====================
void updateFirebase() {
  static unsigned long lastUpdate = 0;
  
  if (!wifiOK || millis() - lastUpdate < FIREBASE_UPDATE_INTERVAL) {
    return;
  }
  
  unsigned long long timestamp = getCurrentTimestamp();
  
  // Device data
  DynamicJsonDocument dataDoc(512);
  dataDoc["deviceId"] = DEVICE_ID;
  dataDoc["flowRate"] = flowRate;
  dataDoc["totalLitres"] = totalLitres;
  dataDoc["valveState"] = valveState ? "OPEN" : "CLOSED";
  dataDoc["status"] = "online";
  dataDoc["batteryPercentage"] = batteryPercent;
  dataDoc["timestamp"] = timestamp;
  
  String dataJson;
  serializeJson(dataDoc, dataJson);
  
  firebasePUT("/devices/" + String(DEVICE_ID) + "/data", dataJson);
  
  // Device info
  DynamicJsonDocument infoDoc(256);
  infoDoc["status"] = "online";
  infoDoc["lastSeen"] = timestamp;
  
  String infoJson;
  serializeJson(infoDoc, infoJson);
  
  firebasePATCH("/devices/" + String(DEVICE_ID) + "/info", infoJson);
  
  lastUpdate = millis();
}

// ==================== SAVE HISTORY ====================
void saveHistory() {
  static unsigned long lastHistory = 0;
  static bool lastValveState = false;
  static float lastFlowRate = 0;
  
  if (!wifiOK || millis() - lastHistory < HISTORY_SAVE_INTERVAL) {
    return;
  }
  
  bool shouldSave = (flowRate > 0.1) || 
                    (valveState != lastValveState) || 
                    (abs(flowRate - lastFlowRate) > 0.5);
  
  if (!shouldSave) {
    lastHistory = millis();
    return;
  }
  
  unsigned long long timestamp = getCurrentTimestamp();
  
  DynamicJsonDocument historyDoc(512);
  historyDoc["timestamp"] = timestamp;
  historyDoc["flowRate"] = flowRate;
  historyDoc["totalLitres"] = totalLitres;
  historyDoc["valveState"] = valveState ? "OPEN" : "CLOSED";
  historyDoc["batteryPercentage"] = batteryPercent;
  
  String historyJson;
  serializeJson(historyDoc, historyJson);
  
  String historyKey = String((unsigned long)(timestamp / 1000));
  
  if (firebasePUT("/history/" + String(DEVICE_ID) + "/" + historyKey, historyJson)) {
    Serial.println("üíæ History saved");
    lastValveState = valveState;
    lastFlowRate = flowRate;
  }
  
  lastHistory = millis();
}

// ==================== CHECK COMMANDS ====================
void checkCommands() {
  static unsigned long lastCheck = 0;
  
  if (!wifiOK || millis() - lastCheck < COMMAND_CHECK_INTERVAL) {
    return;
  }
  
  // Valve control
  String valveCmd = firebaseGET("/devices/" + String(DEVICE_ID) + "/commands/valveControl");
  valveCmd.trim();
  valveCmd.replace("\"", "");
  
  if (valveCmd == "true") {
    Serial.println("üì© OPEN valve");
    setValve(true);
    firebaseDELETE("/devices/" + String(DEVICE_ID) + "/commands/valveControl");
  } else if (valveCmd == "false") {
    Serial.println("üì© CLOSE valve");
    setValve(false);
    firebaseDELETE("/devices/" + String(DEVICE_ID) + "/commands/valveControl");
  }
  
  // Reset total
  String resetCmd = firebaseGET("/devices/" + String(DEVICE_ID) + "/commands/resetTotal");
  resetCmd.trim();
  resetCmd.replace("\"", "");
  
  if (resetCmd == "true") {
    Serial.println("üì© RESET total");
    totalLitres = 0;
    prefs.begin("aquatrack", false);
    prefs.putFloat("total", 0);
    prefs.end();
    firebaseDELETE("/devices/" + String(DEVICE_ID) + "/commands/resetTotal");
  }
  
  lastCheck = millis();
}

// ==================== WIFI SETUP ====================
bool setupWiFi() {
  currentState = STATE_WIFI_GUIDE;
  stateStartTime = millis();
  
  wm.setTitle("AquaTrackX Setup");
  wm.setConfigPortalTimeout(180);
  
  String apName = "AquaTrackX_" + String(DEVICE_ID);
  bool connected = wm.autoConnect(apName.c_str());
  
  if (!connected) {
    Serial.println("‚ùå WiFi timeout");
    return false;
  }
  
  Serial.println("‚úÖ WiFi connected!");
  Serial.printf("SSID: %s\n", WiFi.SSID().c_str());
  Serial.printf("IP: %s\n", WiFi.localIP().toString().c_str());
  Serial.printf("RSSI: %d dBm\n", WiFi.RSSI());
  
  wifiOK = true;
  
  // Show connected screen
  currentState = STATE_CONNECTED;
  displayConnected();
  delay(2000);
  
  // Setup time
  setupTime();
  
  // Register device
  registerDevice();
  
  // Switch to normal display
  currentState = STATE_NORMAL;
  
  return true;
}

// ==================== SETUP ====================
void setup() {
  Serial.begin(115200);
  delay(100);
  
  Serial.println("\n\n========================================");
  Serial.println("  AquaTrackX Water Monitor");
  Serial.println("========================================");
  Serial.printf("Device: %s\n", DEVICE_ID);
  Serial.printf("Version: v%s\n", FIRMWARE_VERSION);
  Serial.printf("Build: %s\n", __DATE__);
  Serial.println("========================================\n");
  
  // Initialize pins
  pinMode(FLOW_PIN, INPUT_PULLUP);
  pinMode(RELAY_PIN, OUTPUT);
  pinMode(BATTERY_PIN, INPUT);
  pinMode(CONFIG_BUTTON_PIN, INPUT_PULLUP);
  
  digitalWrite(RELAY_PIN, LOW);
  attachInterrupt(FLOW_PIN, pulseCounter, FALLING);
  
  // Initialize display
  Wire.begin(21, 22);
  if (!display.begin(0x3C, true)) {
    Serial.println("‚ùå Display failed!");
  }
  
  display.clearDisplay();
  display.setTextColor(SH110X_WHITE);
  
  // Welcome screen
  currentState = STATE_WELCOME;
  displayWelcome();
  delay(3000);
  
  // Load saved data
  prefs.begin("aquatrack", false);
  totalLitres = prefs.getFloat("total", 0.0);
  prefs.end();
  Serial.printf("üìä Loaded: %.2fL\n", totalLitres);
  
  // Check for WiFi reset
  if (digitalRead(CONFIG_BUTTON_PIN) == LOW) {
    Serial.println("üîÑ Resetting WiFi...");
    
    display.clearDisplay();
    display.setTextSize(1);
    display.setCursor(10, 28);
    display.println("Resetting WiFi...");
    display.display();
    
    delay(2000);
    wm.resetSettings();
  }
  
  // Setup WiFi with guide
  currentState = STATE_CONNECTING;
  if (!setupWiFi()) {
    currentState = STATE_ERROR;
    displayError("WiFi Failed");
    delay(3000);
    ESP.restart();
  }
  
  Serial.println("\n‚úÖ Setup complete!\n");
}

// ==================== MAIN LOOP ====================
void loop() {
  static unsigned long lastBattery = 0;
  static unsigned long lastDisplay = 0;
  static unsigned long buttonStart = 0;
  
  // Long press for WiFi reset
  if (digitalRead(CONFIG_BUTTON_PIN) == LOW) {
    if (buttonStart == 0) {
      buttonStart = millis();
    } else if (millis() - buttonStart > 5000) {
      Serial.println("üîÑ WiFi reset");
      
      display.clearDisplay();
      display.setTextSize(1);
      display.setCursor(10, 28);
      display.println("Resetting WiFi...");
      display.display();
      
      wm.resetSettings();
      delay(1000);
      ESP.restart();
    }
  } else {
    buttonStart = 0;
  }
  
  // Update battery
  if (millis() - lastBattery >= BATTERY_UPDATE_INTERVAL) {
    batteryPercent = readBatteryPercentage();
    lastBattery = millis();
  }
  
  // Measure flow
  measureFlow();
  
  // WiFi tasks
  if (wifiOK && WiFi.status() == WL_CONNECTED) {
    updateFirebase();
    saveHistory();
    checkCommands();
    
    // Re-sync time every hour
    static unsigned long lastTimeSync = 0;
    if (millis() - lastTimeSync > 3600000) {
      setupTime();
      lastTimeSync = millis();
    }
  } else if (wifiOK && WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ö†Ô∏è WiFi lost");
    
    wifiOK = false;
    registered = false;
    currentState = STATE_CONNECTING;
    
    if (WiFi.reconnect()) {
      Serial.println("‚úÖ Reconnected");
      wifiOK = true;
      currentState = STATE_NORMAL;
      setupTime();
      registerDevice();
    } else {
      setupWiFi();
    }
  }
  
  // Update display
  if (millis() - lastDisplay >= DISPLAY_UPDATE_INTERVAL) {
    updateDisplay();
    lastDisplay = millis();
  }
  
  delay(10);
}
