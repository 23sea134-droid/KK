#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SH110X.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <WiFiManager.h>
#include <Preferences.h>
#include <ArduinoJson.h>

// ==================== CONFIG ====================
#define DEVICE_ID "WM001"  // Change this for each device
#define FIREBASE_HOST "aquatrackx-default-rtdb.asia-southeast1.firebasedatabase.app"
#define FIREBASE_AUTH ""  // Leave blank if using public rules, or add your secret
#define FLOW_PIN 27
#define RELAY_PIN 19
#define BATTERY_PIN 35
#define CONFIG_BUTTON_PIN 0  // Boot button for reconfiguration

// ==================== GLOBALS ====================
Adafruit_SH1106G display(128, 64, &Wire, -1);
WiFiManager wm;
Preferences prefs;
HTTPClient http;

volatile int pulseCount = 0;
float flowRate = 0, totalLitres = 0;
bool valveState = false, wifiOK = false, registered = false;
int battery = 0;
unsigned long lastHistorySave = 0;

// ==================== HELPERS ====================
void IRAM_ATTR pulseCounter() { 
  pulseCount++; 
}

void updateDisplay() {
  display.clearDisplay();
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.printf("Bat:%d%% Flow:%.1fL/m\nTotal:%.2fL\nValve:%s\n\nStatus:%s", 
    battery, flowRate, totalLitres, valveState ? "OPEN" : "CLOSED",
    registered ? "Online" : wifiOK ? "WiFi OK" : "Setup");
  display.display();
}

void setValve(bool state) {
  valveState = state;
  digitalWrite(RELAY_PIN, state ? HIGH : LOW);
  Serial.printf("Valve %s\n", state ? "OPENED" : "CLOSED");
}

void measureFlow() {
  static unsigned long lastTime = 0;
  if (millis() - lastTime > 1000) {
    detachInterrupt(FLOW_PIN);
    flowRate = pulseCount / 7.5;
    if (valveState && flowRate > 0.1) {
      totalLitres += flowRate / 60.0;
    }
    
    // Save total litres to flash every 10L
    static float lastSaved = 0;
    if (totalLitres - lastSaved >= 10) {
      prefs.begin("wm", false);
      prefs.putFloat("total", totalLitres);
      prefs.end();
      lastSaved = totalLitres;
      Serial.printf("Total saved: %.2fL\n", totalLitres);
    }
    
    pulseCount = 0;
    lastTime = millis();
    attachInterrupt(FLOW_PIN, pulseCounter, FALLING);
  }
}

// ==================== FIXED BATTERY READING WITH SMART CALIBRATION ====================
int readBatteryPercentage() {
  // Average 10 readings to reduce noise
  long adcSum = 0;
  for (int i = 0; i < 10; i++) {
    adcSum += analogRead(BATTERY_PIN);
    delay(1);
  }
  int adc = adcSum / 10;
  
  // Calculate voltage at GPIO35 (0-3.3V range)
  float gpioVoltage = (adc / 4095.0) * 3.3;
  
  // Calculate 5V rail voltage using voltage divider formula
  // Your circuit: 5V ‚Üí 100kŒ© ‚Üí GPIO35 ‚Üí 47kŒ© ‚Üí GND
  // Voltage divider ratio: (100k + 47k) / 47k = 3.1277
  float rail5V = gpioVoltage * 3.1277;
  
  // ===== SMART BATTERY CALCULATION =====
  // Based on typical 5V regulator behavior with 12V input:
  // - USB power or full battery: 5.0V ¬± 0.05V
  // - Battery dropping: 4.8V - 5.0V
  // - Low battery: 4.2V - 4.8V
  // - Critical: < 4.2V (regulator brownout)
  
  int batteryPercent;
  
  if (rail5V >= 4.95) {
    // Excellent - USB or fully charged battery
    batteryPercent = 100;
  } else if (rail5V >= 4.80) {
    // Good - 80-99%
    batteryPercent = map((int)(rail5V * 100), 480, 495, 80, 99);
  } else if (rail5V >= 4.50) {
    // Fair - 30-79%
    batteryPercent = map((int)(rail5V * 100), 450, 480, 30, 79);
  } else if (rail5V >= 4.20) {
    // Low - 10-29%
    batteryPercent = map((int)(rail5V * 100), 420, 450, 10, 29);
  } else {
    // Critical - 0-9%
    batteryPercent = map((int)(rail5V * 100), 380, 420, 0, 9);
  }
  
  batteryPercent = constrain(batteryPercent, 0, 100);
  
  // Debug output every 10 seconds
  static unsigned long lastDebug = 0;
  if (millis() - lastDebug > 10000) {
    Serial.println("\n========== BATTERY STATUS ==========");
    Serial.printf("ADC: %d\n", adc);
    Serial.printf("GPIO35: %.3fV\n", gpioVoltage);
    Serial.printf("5V Rail: %.3fV\n", rail5V);
    Serial.printf("Battery: %d%%\n", batteryPercent);
    
    if (rail5V >= 4.95) {
      Serial.println("Status: EXCELLENT (USB/Full)");
    } else if (rail5V >= 4.80) {
      Serial.println("Status: GOOD");
    } else if (rail5V >= 4.50) {
      Serial.println("Status: FAIR");
    } else if (rail5V >= 4.20) {
      Serial.println("Status: LOW - Charge Soon");
    } else {
      Serial.println("Status: CRITICAL - Charge Now!");
    }
    Serial.println("====================================\n");
    lastDebug = millis();
  }
  
  return batteryPercent;
}

// ==================== FIREBASE HTTP ====================
String firebaseURL(String path) {
  String url = "https://" + String(FIREBASE_HOST) + path + ".json";
  if (String(FIREBASE_AUTH).length() > 0) {
    url += "?auth=" + String(FIREBASE_AUTH);
  }
  return url;
}

bool firebasePUT(String path, String json) {
  if (!wifiOK) return false;
  
  for (int retry = 0; retry < 3; retry++) {
    http.begin(firebaseURL(path));
    http.addHeader("Content-Type", "application/json");
    int code = http.PUT(json);
    String response = http.getString();
    http.end();
    
    if (code == 200) {
      Serial.printf("PUT %s: OK\n", path.c_str());
      return true;
    }
    
    Serial.printf("PUT %s: FAILED (%d) - Retry %d/3\n", path.c_str(), code, retry + 1);
    delay(1000);
  }
  
  Serial.printf("PUT %s: FAILED after 3 retries\n", path.c_str());
  return false;
}

bool firebasePATCH(String path, String json) {
  if (!wifiOK) return false;
  
  http.begin(firebaseURL(path));
  http.addHeader("Content-Type", "application/json");
  int code = http.PATCH(json);
  String response = http.getString();
  http.end();
  
  if (code == 200) {
    Serial.printf("PATCH %s: OK\n", path.c_str());
    return true;
  } else {
    Serial.printf("PATCH %s: FAILED (%d) - %s\n", path.c_str(), code, response.c_str());
    return false;
  }
}

String firebaseGET(String path) {
  if (!wifiOK) return "";
  
  http.begin(firebaseURL(path));
  int code = http.GET();
  String response = (code == 200) ? http.getString() : "";
  http.end();
  
  return response;
}

bool firebaseDELETE(String path) {
  if (!wifiOK) return false;
  
  http.begin(firebaseURL(path));
  int code = http.sendRequest("DELETE");
  http.end();
  
  if (code == 200) {
    Serial.printf("DELETE %s: OK\n", path.c_str());
    return true;
  } else {
    Serial.printf("DELETE %s: FAILED (%d)\n", path.c_str(), code);
    return false;
  }
}

// ==================== DEVICE REGISTRATION ====================
void registerDevice() {
  if (registered) return;
  
  Serial.println("Registering device with Firebase...");
  
  // Create device info document
  DynamicJsonDocument doc(512);
  doc["deviceId"] = DEVICE_ID;
  doc["deviceName"] = "AquaTrackX " + String(DEVICE_ID);
  doc["name"] = "AquaTrackX " + String(DEVICE_ID);
  doc["location"] = "Not Set";
  doc["type"] = "smart-water-monitor";
  doc["status"] = "online";
  doc["addedAt"] = millis() / 1000;
  doc["lastSeen"] = millis() / 1000;
  doc["version"] = "1.0.0";
  doc["firmwareDate"] = '_DATE_';
  
  String json;
  serializeJson(doc, json);
  
  // Write to devices/{DEVICE_ID}/info
  bool success = firebasePUT("/devices/" + String(DEVICE_ID) + "/info", json);
  
  if (success) {
    registered = true;
    Serial.println("‚úÖ Device registered successfully");
  } else {
    Serial.println("‚ùå Device registration failed");
  }
}

// ==================== UPDATE FIREBASE DATA ====================
void updateFirebase() {
  static unsigned long lastUpdate = 0;
  if (!wifiOK || millis() - lastUpdate < 3000) return;
  
  // Update real-time data at devices/{DEVICE_ID}/data
  DynamicJsonDocument dataDoc(512);
  dataDoc["deviceId"] = DEVICE_ID;
  dataDoc["flowRate"] = flowRate;
  dataDoc["totalLitres"] = totalLitres;
  dataDoc["valveState"] = valveState ? "OPEN" : "CLOSED";
  dataDoc["status"] = "online";
  dataDoc["batteryPercentage"] = battery;
  dataDoc["timestamp"] = millis();
  
  String dataJson;
  serializeJson(dataDoc, dataJson);
  
  bool dataSuccess = firebasePUT("/devices/" + String(DEVICE_ID) + "/data", dataJson);
  
  // Update device info status and lastSeen
  DynamicJsonDocument infoDoc(256);
  infoDoc["status"] = "online";
  infoDoc["lastSeen"] = millis();
  
  String infoJson;
  serializeJson(infoDoc, infoJson);
  
  bool infoSuccess = firebasePATCH("/devices/" + String(DEVICE_ID) + "/info", infoJson);
  
  if (dataSuccess && infoSuccess) {
    Serial.println("‚úÖ Firebase data updated");
  } else {
    Serial.println("‚ö† Firebase update incomplete");
  }
  
  lastUpdate = millis();
}

// ==================== SAVE HISTORY ====================
void saveHistory() {
  static unsigned long lastHistory = 0;
  
  // Save history every 5 minutes (288 records per day)
  if (!wifiOK || millis() - lastHistory < 300000) return;
  
  // Only save history if there's flow or valve state changed
  static bool lastValveState = false;
  static float lastFlowRate = 0;
  
  bool shouldSave = (flowRate > 0.1) || 
                    (valveState != lastValveState) || 
                    (abs(flowRate - lastFlowRate) > 0.5);
  
  if (!shouldSave) {
    lastHistory = millis();
    return;
  }
  
  Serial.println("Saving history record...");
  
  DynamicJsonDocument historyDoc(512);
  historyDoc["timestamp"] = millis();
  historyDoc["flowRate"] = flowRate;
  historyDoc["totalLitres"] = totalLitres;
  historyDoc["valveState"] = valveState ? "OPEN" : "CLOSED";
  historyDoc["batteryPercentage"] = battery;
  historyDoc["recordedAt"] = millis();
  
  String historyJson;
  serializeJson(historyDoc, historyJson);
  
  // Generate a unique key using timestamp
  String historyKey = String(millis());
  
  bool success = firebasePUT("/history/" + String(DEVICE_ID) + "/" + historyKey, historyJson);
  
  if (success) {
    Serial.println("‚úÖ History record saved");
    lastValveState = valveState;
    lastFlowRate = flowRate;
  } else {
    Serial.println("‚ùå History save failed");
  }
  
  lastHistory = millis();
}

// ==================== CHECK COMMANDS ====================
void checkCommands() {
  if (!wifiOK) return;
  
  static unsigned long lastCheck = 0;
  if (millis() - lastCheck < 2000) return; // Check every 2 seconds
  
  // Check valve control command
  String valveCmd = firebaseGET("/devices/" + String(DEVICE_ID) + "/commands/valveControl");
  valveCmd.trim();
  valveCmd.replace("\"", ""); // Remove quotes
  
  if (valveCmd == "true") {
    Serial.println("üì© Valve OPEN command received");
    setValve(true);
    firebaseDELETE("/devices/" + String(DEVICE_ID) + "/commands/valveControl");
  } else if (valveCmd == "false") {
    Serial.println("üì© Valve CLOSE command received");
    setValve(false);
    firebaseDELETE("/devices/" + String(DEVICE_ID) + "/commands/valveControl");
  }
  
  // Check reset total command
  String resetCmd = firebaseGET("/devices/" + String(DEVICE_ID) + "/commands/resetTotal");
  resetCmd.trim();
  resetCmd.replace("\"", "");
  
  if (resetCmd == "true") {
    Serial.println("üì© Reset Total command received");
    totalLitres = 0;
    prefs.begin("wm", false);
    prefs.putFloat("total", 0);
    prefs.end();
    firebaseDELETE("/devices/" + String(DEVICE_ID) + "/commands/resetTotal");
    Serial.println("‚úÖ Total litres reset to 0");
  }
  
  lastCheck = millis();
}

// ==================== WIFI SETUP ====================
bool setupWiFiManager() {
  // Display setup message
  display.clearDisplay();
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.println("WiFi Setup Mode");
  display.println("Connect to:");
  display.setTextSize(2);
  display.setCursor(0, 20);
  display.println("AquaTrackX");
  display.println(DEVICE_ID);
  display.setTextSize(1);
  display.setCursor(0, 50);
  display.println("No password needed");
  display.display();

  // Set WiFiManager title
  wm.setTitle("AquaTrackX Setup");
  
  // Set timeout for configuration portal (3 minutes)
  wm.setConfigPortalTimeout(180);
  
  // Try to connect, if it fails, start configuration portal (no password)
  String apName = "AquaTrackX_" + String(DEVICE_ID);
  bool res = wm.autoConnect(apName.c_str());
  
  if (!res) {
    Serial.println("Failed to connect and hit timeout");
    return false;
  } else {
    Serial.println("‚úÖ Connected to WiFi!");
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());
    Serial.print("SSID: ");
    Serial.println(WiFi.SSID());
    Serial.print("RSSI: ");
    Serial.println(WiFi.RSSI());
    
    wifiOK = true;
    registerDevice();
    return true;
  }
}

// ==================== SETUP ====================
void setup() {
  Serial.begin(115200);
  Serial.println("\n\n========================================");
  Serial.println("Starting AquaTrackX Water Monitor");
  Serial.println("Device ID: " + String(DEVICE_ID));
  Serial.println("========================================\n");
  
  // Initialize pins
  pinMode(FLOW_PIN, INPUT_PULLUP);
  pinMode(RELAY_PIN, OUTPUT);
  pinMode(BATTERY_PIN, INPUT);
  pinMode(CONFIG_BUTTON_PIN, INPUT_PULLUP);
  digitalWrite(RELAY_PIN, LOW);
  attachInterrupt(FLOW_PIN, pulseCounter, FALLING);
  
  // Initialize display
  Wire.begin(21, 22);
  if (!display.begin(0x3C, true)) {
    Serial.println("SH1106 allocation failed");
  }
  
  display.clearDisplay();
  display.setTextColor(SH110X_WHITE);
  display.setTextSize(2);
  display.setCursor(5, 20);
  display.println("AquaTrackX");
  display.setTextSize(1);
  display.setCursor(20, 45);
  display.print(DEVICE_ID);
  display.display();
  delay(2000);
  
  // Load saved total litres from flash
  prefs.begin("wm", false);
  totalLitres = prefs.getFloat("total", 0);
  prefs.end();
  Serial.printf("Loaded total litres: %.2fL\n", totalLitres);
  
  // Check if config button is pressed for WiFi reset
  if (digitalRead(CONFIG_BUTTON_PIN) == LOW) {
    display.clearDisplay();
    display.setCursor(0, 20);
    display.println("Resetting WiFi...");
    display.display();
    delay(2000);
    wm.resetSettings();
    Serial.println("WiFi settings reset");
  }
  
  // Setup WiFi using WiFiManager
  if (!setupWiFiManager()) {
    Serial.println("‚ùå WiFi setup failed, restarting in 3 seconds...");
    delay(3000);
    ESP.restart();
  }
  
  Serial.println("\n‚úÖ Setup complete - entering main loop\n");
}

// ==================== MAIN LOOP ====================
void loop() {
  static unsigned long lastBattery = 0, lastDisplay = 0;
  static unsigned long buttonPressStart = 0;
  
  // Check for long press on config button to reset WiFi
  if (digitalRead(CONFIG_BUTTON_PIN) == LOW) {
    if (buttonPressStart == 0) {
      buttonPressStart = millis();
    } else if (millis() - buttonPressStart > 5000) {
      // Long press detected - reset WiFi
      display.clearDisplay();
      display.setCursor(0, 20);
      display.println("Resetting WiFi...");
      display.display();
      wm.resetSettings();
      delay(1000);
      ESP.restart();
    }
  } else {
    buttonPressStart = 0;
  }
  
  // Update battery level every 10 seconds using the corrected smart formula
  if (millis() - lastBattery > 10000) {
    battery = readBatteryPercentage();  // Now uses the corrected smart function
    lastBattery = millis();
  }
  
  // Measure flow continuously
  measureFlow();
  
  // WiFi connection management
  if (wifiOK && WiFi.status() == WL_CONNECTED) {
    // Update Firebase data
    updateFirebase();
    
    // Save history
    saveHistory();
    
    // Check for commands
    checkCommands();
  } else if (wifiOK && WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ö† WiFi connection lost, attempting to reconnect...");
    wifiOK = false;
    registered = false;
    
    // Attempt to reconnect
    if (WiFi.reconnect()) {
      Serial.println("‚úÖ WiFi reconnected");
      wifiOK = true;
      registerDevice();
    } else {
      Serial.println("‚ùå Reconnect failed, restarting WiFiManager...");
      setupWiFiManager();
    }
  }
  
  // Update display every 500ms
  if (millis() - lastDisplay > 500) {
    updateDisplay();
    lastDisplay = millis();
  }
  
  delay(10);
}
